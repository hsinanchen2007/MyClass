//# 第五階段：互斥鎖基礎 (std::mutex)//

//## 課程 5.2：互斥鎖的工作原理//

//---//

//### 引言//

//在上一課，我們學會了如何使用 `lock()` 和 `unlock()` 來保護共享資料。但互斥鎖內部究竟是如何運作的？為什麼它能確保同一時間只有一個執行緒進入臨界區段？本課將揭開互斥鎖的神秘面紗。//

//---//

//### 一、互斥鎖的核心概念//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                    互斥鎖的本質                              │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  互斥鎖本質上是一個「狀態變數」+「等待機制」的組合：          │
//│                                                             │
//│    ┌─────────────────────────────────────────┐              │
//│    │  Mutex 內部狀態                          │              │
//│    ├─────────────────────────────────────────┤              │
//│    │  • 鎖定狀態（locked / unlocked）         │              │
//│    │  • 擁有者（哪個執行緒持有鎖）            │              │
//│    │  • 等待佇列（等待獲取鎖的執行緒）        │              │
//│    └─────────────────────────────────────────┘              │
//│                                                             │
//│  關鍵：狀態的改變必須是「原子操作」                          │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//---//

//### 二、原子操作：互斥鎖的基石//

//互斥鎖依賴 CPU 提供的**原子指令**來確保狀態改變不會被中斷。//

//#### 什麼是原子操作？//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                      原子操作                                │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  原子（Atomic）= 不可分割                                    │
//│                                                             │
//│  非原子操作（如 counter++）：                                │
//│                                                             │
//│      ┌─────┐    ┌─────┐    ┌─────┐                         │
//│      │ 讀取 │ → │ +1  │ → │ 寫回 │   ← 三個步驟，可被中斷    │
//│      └─────┘    └─────┘    └─────┘                         │
//│                                                             │
//│  原子操作：                                                  │
//│                                                             │
//│      ┌─────────────────────┐                                │
//│      │   讀取 + 修改 + 寫回  │   ← 一個不可分割的操作        │
//│      └─────────────────────┘                                │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### CPU 層級的原子指令//

//現代 CPU 提供特殊指令來實現原子操作：//

//| 指令 | 架構 | 功能 |
//|------|------|------|
//| `LOCK CMPXCHG` | x86/x64 | Compare-And-Swap (CAS) |
//| `LOCK XCHG` | x86/x64 | 原子交換 |
//| `LDREX/STREX` | ARM (舊) | Load-Exclusive / Store-Exclusive |
//| `LDXR/STXR` | ARM (新) | 原子載入/儲存 |//

//---//

//### 三、Test-And-Set：最簡單的鎖實現//

//#### 概念說明//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                   Test-And-Set (TAS)                        │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  操作：原子地執行「讀取舊值 + 設定新值」                      │
//│                                                             │
//│  虛擬碼：                                                    │
//│                                                             │
//│    bool test_and_set(bool* flag) {                         │
//│        bool old = *flag;   // ─┐                            │
//│        *flag = true;       // ─┴─ 這兩步是原子的            │
//│        return old;                                          │
//│    }                                                        │
//│                                                             │
//│  使用方式：                                                  │
//│                                                             │
//│    while (test_and_set(&locked)) {                         │
//│        // 自旋等待                                          │
//│    }                                                        │
//│    // 獲得鎖，進入臨界區段                                   │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### 簡化的自旋鎖實現（概念示範）//

//```cpp
//// 檔案：lesson_5_2_spinlock_concept.cpp
//// 說明：展示自旋鎖的基本概念（僅供理解，非生產環境使用）//

//#include <iostream>
//#include <thread>
//#include <atomic>
//#include <vector>//

//class SimpleSpinlock {
//private:
//    std::atomic<bool> locked{false};
//    
//public:
//    void lock() {
//        // exchange 是原子操作：設定新值並返回舊值
//        while (locked.exchange(true)) {
//            // 如果舊值是 true，表示已被鎖定，繼續自旋
//            // 這裡可以加入 yield 或 pause 來減少 CPU 消耗
//        }
//        // 如果舊值是 false，表示成功獲取鎖
//    }
//    
//    void unlock() {
//        locked.store(false);
//    }
//};//

//// 測試
//SimpleSpinlock spinlock;
//int counter = 0;//

//void increment() {
//    for (int i = 0; i < 100000; ++i) {
//        spinlock.lock();
//        ++counter;
//        spinlock.unlock();
//    }
//}//

//int main() {
//    std::thread t1(increment);
//    std::thread t2(increment);
//    
//    t1.join();
//    t2.join();
//    
//    std::cout << "預期: 200000" << std::endl;
//    std::cout << "實際: " << counter << std::endl;
//    
//    return 0;
//}
//```//

//#### 編譯與執行//

//```bash
//g++ -std=c++17 -pthread -o spinlock lesson_5_2_spinlock_concept.cpp
//./spinlock
//```//

//#### 輸出//

//```
//預期: 200000
//實際: 200000
//```//

//---//

//### 四、Compare-And-Swap (CAS)：更強大的原子操作//

//#### CAS 操作原理//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                  Compare-And-Swap (CAS)                     │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  操作：比較並交換                                            │
//│                                                             │
//│    bool CAS(int* ptr, int expected, int desired) {         │
//│        if (*ptr == expected) {   // ─┐                      │
//│            *ptr = desired;       //  │ 整個操作是原子的      │
//│            return true;          //  │                      │
//│        }                         // ─┘                      │
//│        return false;                                        │
//│    }                                                        │
//│                                                             │
//│  意義：「只有當前值符合預期時，才更新」                       │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### CAS 實現鎖的範例//

//```cpp
//// 檔案：lesson_5_2_cas_lock.cpp
//// 說明：使用 CAS 實現的自旋鎖//

//#include <iostream>
//#include <thread>
//#include <atomic>//

//class CASSpinlock {
//private:
//    std::atomic<bool> locked{false};
//    
//public:
//    void lock() {
//        bool expected = false;
//        
//        // compare_exchange_strong：
//        // 如果 locked == expected(false)，則設為 true，返回 true
//        // 如果 locked != expected，則 expected 被更新為 locked 的值，返回 false
//        while (!locked.compare_exchange_strong(expected, true)) {
//            expected = false;  // 重設 expected 為 false
//            // 繼續嘗試
//        }
//    }
//    
//    void unlock() {
//        locked.store(false);
//    }
//};//

//CASSpinlock cas_lock;
//int shared_counter = 0;//

//void worker() {
//    for (int i = 0; i < 100000; ++i) {
//        cas_lock.lock();
//        ++shared_counter;
//        cas_lock.unlock();
//    }
//}//

//int main() {
//    std::thread t1(worker);
//    std::thread t2(worker);
//    
//    t1.join();
//    t2.join();
//    
//    std::cout << "counter = " << shared_counter << std::endl;
//    
//    return 0;
//}
//```//

//---//

//### 五、自旋鎖 vs 睡眠鎖//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                自旋鎖 vs 睡眠鎖                              │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  自旋鎖（Spinlock）                                         │
//│  ─────────────────                                          │
//│  • 等待時不斷循環檢查鎖狀態                                  │
//│  • 持續佔用 CPU                                             │
//│  • 適合：鎖持有時間極短的情況                                │
//│                                                             │
//│    while (locked) {                                         │
//│        // 忙等待，消耗 CPU                                   │
//│    }                                                        │
//│                                                             │
//│  ─────────────────────────────────────────────────────────  │
//│                                                             │
//│  睡眠鎖（Sleeping Lock / Blocking Lock）                    │
//│  ───────────────────────────────────────                    │
//│  • 等待時讓出 CPU，進入睡眠狀態                              │
//│  • 需要作業系統介入（系統呼叫）                              │
//│  • 適合：鎖持有時間較長的情況                                │
//│                                                             │
//│    if (locked) {                                            │
//│        加入等待佇列;                                         │
//│        睡眠;  // 讓出 CPU                                   │
//│    }                                                        │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### 比較表//

//| 特性 | 自旋鎖 | 睡眠鎖 |
//|------|--------|--------|
//| 等待方式 | 忙等待（busy-wait） | 睡眠（block） |
//| CPU 消耗 | 高（持續佔用） | 低（讓出 CPU） |
//| 上下文切換 | 無 | 有（開銷較大） |
//| 適用場景 | 臨界區段極短 | 臨界區段較長 |
//| 適用環境 | 多核心系統 | 任何環境 |//

//---//

//### 六、std::mutex 的實際實現//

//`std::mutex` 通常採用**混合策略**：先自旋一小段時間，若仍無法獲取鎖，再進入睡眠。//

//```
//┌─────────────────────────────────────────────────────────────┐
//│              std::mutex 的混合策略                           │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│                    lock() 被呼叫                            │
//│                         │                                   │
//│                         ▼                                   │
//│                  ┌─────────────┐                            │
//│                  │ 嘗試獲取鎖  │                            │
//│                  └──────┬──────┘                            │
//│                         │                                   │
//│              ┌──────────┴──────────┐                        │
//│              │                     │                        │
//│         成功獲取                失敗                         │
//│              │                     │                        │
//│              ▼                     ▼                        │
//│         進入臨界區段         ┌───────────┐                   │
//│                             │ 自旋等待   │ ← 短暫自旋        │
//│                             │ (數十到    │   （節省系統呼叫） │
//│                             │  數百次)   │                   │
//│                             └─────┬─────┘                   │
//│                                   │                         │
//│                        ┌──────────┴──────────┐              │
//│                        │                     │              │
//│                   獲取成功               仍然失敗            │
//│                        │                     │              │
//│                        ▼                     ▼              │
//│                  進入臨界區段         ┌───────────┐          │
//│                                      │ 系統呼叫   │          │
//│                                      │ 進入睡眠   │          │
//│                                      └───────────┘          │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//---//

//### 七、作業系統層面的實現//

//#### Linux：Futex（Fast Userspace Mutex）//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                     Linux Futex                             │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  設計理念：「無競爭時不需要系統呼叫」                         │
//│                                                             │
//│  ┌─────────────────────────────────────────────────────┐    │
//│  │  無競爭情況（fast path）                             │    │
//│  │  ───────────────────────                             │    │
//│  │  1. 使用原子操作嘗試獲取鎖                           │    │
//│  │  2. 成功 → 直接進入臨界區段（無系統呼叫）            │    │
//│  │  3. 釋放時也只需原子操作                             │    │
//│  └─────────────────────────────────────────────────────┘    │
//│                                                             │
//│  ┌─────────────────────────────────────────────────────┐    │
//│  │  有競爭情況（slow path）                             │    │
//│  │  ───────────────────────                             │    │
//│  │  1. 原子操作失敗                                     │    │
//│  │  2. 呼叫 futex(FUTEX_WAIT) 系統呼叫                  │    │
//│  │  3. 核心將執行緒加入等待佇列                          │    │
//│  │  4. 執行緒睡眠                                       │    │
//│  │  5. 鎖釋放時，呼叫 futex(FUTEX_WAKE) 喚醒等待者      │    │
//│  └─────────────────────────────────────────────────────┘    │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### 簡化的 Futex 概念示範//

//```cpp
//// 檔案：lesson_5_2_futex_concept.cpp
//// 說明：Futex 概念的簡化說明（非實際實現）//

//#include <iostream>
//#include <atomic>//

///*
// * 這是 Futex 的概念說明，不是實際可編譯的程式碼
// * 
// * Futex 的核心思想：
// * 
// * struct futex_mutex {
// *     atomic<int> state;  // 0 = unlocked, 1 = locked (無等待者), 2 = locked (有等待者)
// * };
// * 
// * void lock() {
// *     int expected = 0;
// *     
// *     // Fast path：嘗試 0 → 1（無競爭）
// *     if (state.compare_exchange_strong(expected, 1)) {
// *         return;  // 成功獲取，無需系統呼叫
// *     }
// *     
// *     // Slow path：有競爭
// *     while (true) {
// *         // 標記為「有等待者」
// *         if (expected == 2 || state.compare_exchange_strong(expected, 2)) {
// *             // 系統呼叫：等待 state 變化
// *             futex_wait(&state, 2);
// *         }
// *         
// *         expected = 0;
// *         if (state.compare_exchange_strong(expected, 2)) {
// *             return;  // 成功獲取
// *         }
// *     }
// * }
// * 
// * void unlock() {
// *     // 如果 state 從 1 變成 0，無等待者
// *     if (state.fetch_sub(1) == 1) {
// *         return;  // 無需喚醒
// *     }
// *     
// *     // 有等待者，需要喚醒
// *     state.store(0);
// *     futex_wake(&state, 1);  // 喚醒一個等待者
// * }
// *///

//int main() {
//    std::cout << "Futex 是 Linux 實現高效互斥鎖的機制" << std::endl;
//    std::cout << "無競爭時：純用戶空間原子操作，無系統呼叫" << std::endl;
//    std::cout << "有競爭時：使用系統呼叫讓執行緒睡眠" << std::endl;
//    
//    return 0;
//}
//```//

//---//

//### 八、lock() 的完整流程//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                   lock() 完整流程                           │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  Thread A 呼叫 lock()                                       │
//│         │                                                   │
//│         ▼                                                   │
//│  ┌─────────────────────────────────────┐                    │
//│  │ 1. 原子操作：嘗試將 state 從 0 改為 1 │                    │
//│  └─────────────────┬───────────────────┘                    │
//│                    │                                        │
//│         ┌─────────┴─────────┐                               │
//│         │                   │                               │
//│     CAS 成功             CAS 失敗                            │
//│    (state 是 0)         (state 非 0)                         │
//│         │                   │                               │
//│         ▼                   ▼                               │
//│  ┌─────────────┐    ┌─────────────────┐                     │
//│  │ 獲得鎖      │    │ 2. 自旋等待      │                     │
//│  │ 進入臨界區段│    │    （重試數次）   │                     │
//│  └─────────────┘    └────────┬────────┘                     │
//│                              │                              │
//│                   ┌─────────┴─────────┐                     │
//│                   │                   │                     │
//│               自旋成功             自旋失敗                   │
//│                   │                   │                     │
//│                   ▼                   ▼                     │
//│            ┌─────────────┐    ┌─────────────────┐           │
//│            │ 獲得鎖      │    │ 3. 系統呼叫      │           │
//│            │ 進入臨界區段│    │    進入睡眠      │           │
//│            └─────────────┘    │    等待被喚醒    │           │
//│                               └─────────────────┘           │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//---//

//### 九、unlock() 的完整流程//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                  unlock() 完整流程                          │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  Thread A 呼叫 unlock()                                     │
//│         │                                                   │
//│         ▼                                                   │
//│  ┌─────────────────────────────────────┐                    │
//│  │ 1. 原子操作：將 state 設為 0（或減 1）│                    │
//│  └─────────────────┬───────────────────┘                    │
//│                    │                                        │
//│         ┌─────────┴─────────┐                               │
//│         │                   │                               │
//│     無等待者             有等待者                            │
//│   (舊值表示無人等待)    (舊值表示有人睡眠)                    │
//│         │                   │                               │
//│         ▼                   ▼                               │
//│  ┌─────────────┐    ┌─────────────────┐                     │
//│  │ 直接返回    │    │ 2. 系統呼叫      │                     │
//│  │（無額外開銷）│    │    喚醒一個      │                     │
//│  └─────────────┘    │    等待中的執行緒 │                     │
//│                     └─────────────────┘                     │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//---//

//### 十、記憶體屏障與可見性//

//互斥鎖不僅僅是「排他存取」，還提供**記憶體可見性保證**。//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                   記憶體可見性保證                           │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  問題：現代 CPU 有快取、指令重排                             │
//│                                                             │
//│    Thread A                    Thread B                     │
//│    ─────────                   ─────────                    │
//│    data = 42;                                               │
//│    ready = true;               if (ready) {                 │
//│                                    use(data);  // data 是？ │
//│                                }                            │
//│                                                             │
//│  沒有同步機制時，Thread B 可能看到 ready=true 但 data≠42    │
//│                                                             │
//│  ─────────────────────────────────────────────────────────  │
//│                                                             │
//│  互斥鎖的保證：                                              │
//│                                                             │
//│    Thread A                    Thread B                     │
//│    ─────────                   ─────────                    │
//│    mtx.lock();                                              │
//│    data = 42;                                               │
//│    mtx.unlock();  ─────────→   mtx.lock();                  │
//│        │                       use(data);  // 保證是 42     │
//│        │                       mtx.unlock();                │
//│        │                                                    │
//│        └─ unlock() 包含「釋放屏障」(release barrier)        │
//│           lock() 包含「獲取屏障」(acquire barrier)          │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//#### 記憶體屏障的作用//

//```cpp
//// 檔案：lesson_5_2_memory_barrier.cpp
//// 說明：互斥鎖提供的記憶體可見性保證//

//#include <iostream>
//#include <thread>
//#include <mutex>//

//std::mutex mtx;
//int data = 0;
//bool ready = false;//

//void producer() {
//    mtx.lock();
//    
//    data = 42;       // 寫入資料
//    ready = true;    // 設定標誌
//    
//    mtx.unlock();    // unlock 包含 release barrier
//                     // 保證 data 和 ready 的寫入對其他執行緒可見
//}//

//void consumer() {
//    mtx.lock();      // lock 包含 acquire barrier
//                     // 保證看到 producer 的所有寫入
//    
//    if (ready) {
//        std::cout << "data = " << data << std::endl;  // 保證是 42
//    }
//    
//    mtx.unlock();
//}//

//int main() {
//    std::thread t1(producer);
//    std::thread t2(consumer);
//    
//    t1.join();
//    t2.join();
//    
//    return 0;
//}
//```//

//---//

//### 十一、效能考量//

//```
//┌─────────────────────────────────────────────────────────────┐
//│                   互斥鎖的效能開銷                           │
//├─────────────────────────────────────────────────────────────┤
//│                                                             │
//│  無競爭時（Fast Path）：                                     │
//│  • 約 10-25 奈秒（一次原子操作 + 記憶體屏障）                │
//│  • 純用戶空間，無系統呼叫                                    │
//│                                                             │
//│  有競爭時（Slow Path）：                                     │
//│  • 自旋階段：數百奈秒                                        │
//│  • 若需睡眠：數微秒（系統呼叫開銷）                          │
//│  • 上下文切換：1-10 微秒                                     │
//│                                                             │
//│  ─────────────────────────────────────────────────────────  │
//│                                                             │
//│  優化建議：                                                  │
//│  1. 減少臨界區段的大小                                       │
//│  2. 避免在臨界區段內進行 I/O 操作                           │
//│  3. 考慮使用細粒度鎖或讀寫鎖                                │
//│  4. 高競爭場景考慮無鎖演算法                                │
//│                                                             │
//└─────────────────────────────────────────────────────────────┘
//```//

//---//

//### 十二、本課重點回顧//

//1. **互斥鎖依賴原子操作**：如 Test-And-Set、Compare-And-Swap
//2. **自旋鎖**：忙等待，適合極短臨界區段
//3. **睡眠鎖**：讓出 CPU，適合較長臨界區段
//4. **std::mutex 採用混合策略**：先自旋，再睡眠
//5. **Linux 使用 Futex**：無競爭時無系統呼叫
//6. **互斥鎖提供記憶體可見性保證**：包含記憶體屏障
//7. 無競爭時開銷約 10-25 奈秒，有競爭時可達微秒級//

//---//

//### 下一課預告//

//在 **課程 5.3：try_lock() 非阻塞鎖定** 中，我們將學習：
//- 如何嘗試獲取鎖而不阻塞
//- try_lock() 的返回值處理
//- 非阻塞鎖定的應用場景//

//---//

//準備好繼續嗎？//

// 檔案：lesson_5_2_memory_barrier.cpp
// 說明：互斥鎖提供的記憶體可見性保證



#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int data = 0;
bool ready = false;

void producer() {
    mtx.lock();
    
    data = 42;       // 寫入資料
    ready = true;    // 設定標誌
    
    mtx.unlock();    // unlock 包含 release barrier
                     // 保證 data 和 ready 的寫入對其他執行緒可見
}

void consumer() {
    mtx.lock();      // lock 包含 acquire barrier
                     // 保證看到 producer 的所有寫入
    
    if (ready) {
        std::cout << "data = " << data << std::endl;  // 保證是 42
    }
    
    mtx.unlock();
}

int main() {
    std::thread t1(producer);
    std::thread t2(consumer);
    
    t1.join();
    t2.join();
    
    return 0;
}
