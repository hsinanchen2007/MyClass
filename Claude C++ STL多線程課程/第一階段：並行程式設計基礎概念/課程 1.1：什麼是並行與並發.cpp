/*
# 第一階段：並行程式設計基礎概念

## 課程 1.1：什麼是並行與並發

---

### 引言

在我們開始撰寫任何多執行緒程式碼之前，必須先釐清兩個經常被混淆的核心概念：**並發（Concurrency）** 與 **並行（Parallelism）**。這兩個術語在中文技術文獻中常被混用，但它們描述的是本質上不同的概念。理解這個區別，是掌握多執行緒程式設計的第一步。

---

### 一、從日常生活理解並發與並行

在深入技術定義之前，讓我們先用日常生活的例子來建立直覺。

#### 情境一：一位廚師準備多道菜（並發）

想像一位廚師需要同時準備三道菜：湯、主菜、甜點。這位廚師只有一雙手，他的工作方式是：

1. 先把湯放到爐子上煮
2. 趁湯在煮的時候，開始切主菜的食材
3. 切到一半，回去攪拌一下湯
4. 繼續處理主菜，把它放進烤箱
5. 趁主菜在烤的時候，開始準備甜點
6. 來回切換，直到三道菜都完成

這位廚師在「同時處理」三道菜，但在任何一個瞬間，他實際上只在做一件事。這就是**並發（Concurrency）**——在一段時間內處理多個任務，但不一定是同時執行。

#### 情境二：三位廚師各自準備一道菜（並行）

現在想像有三位廚師，每人負責一道菜：

- 廚師 A 專門煮湯
- 廚師 B 專門做主菜
- 廚師 C 專門做甜點

三位廚師在同一時刻各自工作，真正地同時執行三個任務。這就是**並行（Parallelism）**——在同一時刻同時執行多個任務。

---

### 二、技術定義

#### 並發（Concurrency）

**並發是一種程式的結構化方式，它將程式組織成多個可以獨立執行的任務。**

關鍵特點：
- 強調的是程式的**結構**與**設計**
- 多個任務在**邏輯上**同時進行
- 實際執行時可能是交錯進行（在單核心 CPU 上）
- 任務之間可能有相互依賴或需要協調

用更精確的技術語言來說：並發是指程式具有處理多個任務的**能力**，這些任務的執行時間在邏輯上是重疊的。

#### 並行（Parallelism）

**並行是一種執行方式，指多個任務在同一時刻真正地同時執行。**

關鍵特點：
- 強調的是**執行**與**效能**
- 多個任務在**物理上**同時進行
- 需要多核心 CPU 或多處理器的硬體支援
- 目的通常是提升運算效能

用更精確的技術語言來說：並行是指多個運算在同一時間點**實際上**同時發生。

---

### 三、兩者的關係

並發與並行的關係可以用以下四種組合來理解：

```
┌─────────────────────────────────────────────────────────────┐
│                      並發 vs 並行                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 非並發、非並行：                                          │
│     [任務A完成] → [任務B完成] → [任務C完成]                    │
│     一次只處理一個任務，完成後才開始下一個                       │
│                                                             │
│  2. 並發、非並行（單核心）：                                   │
│     [A1][B1][A2][C1][B2][A3][C2][B3]...                      │
│     多個任務交錯執行，但任一時刻只有一個在執行                   │
│                                                             │
│  3. 並行、非並發：                                            │
│     核心1: [任務A──────────────]                              │
│     核心2: [任務B──────────────]                              │
│     多個獨立任務同時執行，但彼此無關聯                          │
│                                                             │
│  4. 並發且並行（多核心）：                                     │
│     核心1: [A1][A2][B3][A4][C2]...                           │
│     核心2: [B1][C1][B2][A3][B4]...                           │
│     多個相關任務在多核心上同時且交錯執行                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**重要結論**：
- 並發是一種設計概念，與硬體無關
- 並行是一種執行現象，需要硬體支援
- 並發程式在單核心上會以時間分片方式執行
- 並發程式在多核心上可以真正並行執行
- 並行一定是並發的，但並發不一定是並行的

---

### 四、C++ 程式碼示範

讓我們用實際的程式碼來觀察這些概念。

#### 範例程式：觀察並發執行

```cpp
// 檔案名稱：lesson_1_1_concurrency_demo.cpp
// 課程：1.1 - 什麼是並行與並發
// 說明：示範並發執行的基本概念

#include <iostream>
#include <thread>
#include <chrono>

// 模擬一個需要時間的任務
void performTask(const std::string& taskName, int iterations) {
    for (int i = 1; i <= iterations; ++i) {
        // 輸出目前的進度
        std::cout << "[" << taskName << "] 執行第 " << i 
                  << " 次迭代（執行緒 ID: " 
                  << std::this_thread::get_id() << "）" << std::endl;
        
        // 模擬工作需要一些時間
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "[" << taskName << "] 完成！" << std::endl;
}

int main() {
    std::cout << "========================================" << std::endl;
    std::cout << "    並發執行示範程式" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "主執行緒 ID: " << std::this_thread::get_id() << std::endl;
    std::cout << "硬體支援的執行緒數量: " 
              << std::thread::hardware_concurrency() << std::endl;
    std::cout << "----------------------------------------" << std::endl;

    // 記錄開始時間
    auto startTime = std::chrono::steady_clock::now();

    // 方式一：循序執行（非並發）
    std::cout << "\n【方式一】循序執行：" << std::endl;
    auto seqStart = std::chrono::steady_clock::now();
    
    performTask("任務A", 3);
    performTask("任務B", 3);
    performTask("任務C", 3);
    
    auto seqEnd = std::chrono::steady_clock::now();
    auto seqDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
        seqEnd - seqStart).count();
    std::cout << "循序執行總時間: " << seqDuration << " 毫秒" << std::endl;

    std::cout << "\n----------------------------------------" << std::endl;

    // 方式二：並發執行
    std::cout << "\n【方式二】並發執行：" << std::endl;
    auto concStart = std::chrono::steady_clock::now();
    
    // 建立三個執行緒，每個執行緒執行一個任務
    std::thread threadA(performTask, "任務A", 3);
    std::thread threadB(performTask, "任務B", 3);
    std::thread threadC(performTask, "任務C", 3);
    
    // 等待所有執行緒完成
    threadA.join();
    threadB.join();
    threadC.join();
    
    auto concEnd = std::chrono::steady_clock::now();
    auto concDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
        concEnd - concStart).count();
    std::cout << "並發執行總時間: " << concDuration << " 毫秒" << std::endl;

    std::cout << "\n========================================" << std::endl;
    std::cout << "效能比較：" << std::endl;
    std::cout << "循序執行: " << seqDuration << " 毫秒" << std::endl;
    std::cout << "並發執行: " << concDuration << " 毫秒" << std::endl;
    std::cout << "加速比: " << static_cast<double>(seqDuration) / concDuration 
              << " 倍" << std::endl;
    std::cout << "========================================" << std::endl;

    return 0;
}
```

#### 編譯與執行

在你的終端機中執行以下命令：

```bash
# 編譯（需要連結 pthread 函式庫）
g++ -std=c++17 -pthread -o lesson_1_1 lesson_1_1_concurrency_demo.cpp

# 執行
./lesson_1_1
```

#### 預期輸出

```
========================================
    並發執行示範程式
========================================
主執行緒 ID: 140234567891520
硬體支援的執行緒數量: 8
----------------------------------------

【方式一】循序執行：
[任務A] 執行第 1 次迭代（執行緒 ID: 140234567891520）
[任務A] 執行第 2 次迭代（執行緒 ID: 140234567891520）
[任務A] 執行第 3 次迭代（執行緒 ID: 140234567891520）
[任務A] 完成！
[任務B] 執行第 1 次迭代（執行緒 ID: 140234567891520）
[任務B] 執行第 2 次迭代（執行緒 ID: 140234567891520）
[任務B] 執行第 3 次迭代（執行緒 ID: 140234567891520）
[任務B] 完成！
[任務C] 執行第 1 次迭代（執行緒 ID: 140234567891520）
[任務C] 執行第 2 次迭代（執行緒 ID: 140234567891520）
[任務C] 執行第 3 次迭代（執行緒 ID: 140234567891520）
[任務C] 完成！
循序執行總時間: 903 毫秒

----------------------------------------

【方式二】並發執行：
[任務A] 執行第 1 次迭代（執行緒 ID: 140234567891521）
[任務B] 執行第 1 次迭代（執行緒 ID: 140234567891522）
[任務C] 執行第 1 次迭代（執行緒 ID: 140234567891523）
[任務A] 執行第 2 次迭代（執行緒 ID: 140234567891521）
[任務B] 執行第 2 次迭代（執行緒 ID: 140234567891522）
[任務C] 執行第 2 次迭代（執行緒 ID: 140234567891523）
[任務A] 執行第 3 次迭代（執行緒 ID: 140234567891521）
[任務B] 執行第 3 次迭代（執行緒 ID: 140234567891522）
[任務C] 執行第 3 次迭代（執行緒 ID: 140234567891523）
[任務A] 完成！
[任務B] 完成！
[任務C] 完成！
並發執行總時間: 302 毫秒

========================================
效能比較：
循序執行: 903 毫秒
並發執行: 302 毫秒
加速比: 2.99 倍
========================================
```

---

### 五、程式碼逐行解析

讓我們詳細分析這個程式的每個部分：

#### 標頭檔引入

```cpp
#include <iostream>     // 標準輸入輸出
#include <thread>       // C++11 執行緒支援
#include <chrono>       // C++11 時間函式庫
```

`<thread>` 是 C++11 引入的標準執行緒函式庫，提供了 `std::thread` 類別。
`<chrono>` 提供了高精度的時間測量功能。

#### 任務函式

```cpp
void performTask(const std::string& taskName, int iterations) {
    for (int i = 1; i <= iterations; ++i) {
        std::cout << "[" << taskName << "] 執行第 " << i 
                  << " 次迭代（執行緒 ID: " 
                  << std::this_thread::get_id() << "）" << std::endl;
        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "[" << taskName << "] 完成！" << std::endl;
}
```

- `std::this_thread::get_id()` 返回當前執行緒的唯一識別碼
- `std::this_thread::sleep_for()` 讓當前執行緒休眠指定時間
- `std::chrono::milliseconds(100)` 表示 100 毫秒的時間間隔

#### 取得硬體資訊

```cpp
std::cout << "硬體支援的執行緒數量: " 
          << std::thread::hardware_concurrency() << std::endl;
```

`std::thread::hardware_concurrency()` 返回系統支援的並行執行緒數量，通常等於 CPU 核心數（包含超執行緒）。這個值可以幫助我們決定應該建立多少執行緒。

#### 建立與管理執行緒

```cpp
std::thread threadA(performTask, "任務A", 3);
std::thread threadB(performTask, "任務B", 3);
std::thread threadC(performTask, "任務C", 3);

threadA.join();
threadB.join();
threadC.join();
```

- `std::thread` 的建構子接受一個可呼叫物件（函式、Lambda、函式物件等）和其參數
- 執行緒在建構時就開始執行
- `join()` 會阻塞當前執行緒，直到被 join 的執行緒執行完畢

---

### 六、觀察重點

從輸出結果中，我們可以觀察到幾個重要現象：

#### 1. 執行緒 ID 的差異

循序執行時，所有任務的執行緒 ID 相同（都是主執行緒）。並發執行時，每個任務有不同的執行緒 ID，表示它們在不同的執行緒中運行。

#### 2. 執行順序的交錯

在並發執行的輸出中，你會看到任務 A、B、C 的輸出交錯出現。這說明這些任務正在「同時」進行，而不是一個完成後才開始下一個。

#### 3. 執行時間的差異

- 循序執行：約 900 毫秒（3 個任務 × 3 次迭代 × 100 毫秒）
- 並發執行：約 300 毫秒（3 次迭代 × 100 毫秒，因為任務同時進行）

這證明了並發/並行執行可以顯著提升效能。

#### 4. 輸出的不確定性

每次執行程式，並發部分的輸出順序可能略有不同。這是因為作業系統的執行緒排程是非確定性的，這也是多執行緒程式設計的挑戰之一。

---

### 七、單核心 vs 多核心

讓我們更深入理解在不同硬體上的行為差異：

```
單核心 CPU 上的並發執行：
┌────────────────────────────────────────────────┐
│ 時間軸 →                                        │
│                                                │
│ CPU: [A1][B1][C1][A2][B2][C2][A3][B3][C3]      │
│                                                │
│ 看起來「同時」進行，實際上是快速切換             │
│ 總時間 ≈ 循序執行（可能還有切換開銷）            │
└────────────────────────────────────────────────┘

多核心 CPU 上的並發執行（真正的並行）：
┌────────────────────────────────────────────────┐
│ 時間軸 →                                        │
│                                                │
│ 核心1: [A1][A2][A3]                             │
│ 核心2: [B1][B2][B3]                             │
│ 核心3: [C1][C2][C3]                             │
│                                                │
│ 真正同時執行，總時間 ≈ 單一任務的時間            │
└────────────────────────────────────────────────┘
```

---

### 八、常見術語對照

在學習多執行緒程式設計時，你會遇到許多相關術語，以下是它們的對照：

| 英文術語 | 中文翻譯 | 說明 |
|----------|----------|------|
| Concurrency | 並發 | 程式結構上同時處理多個任務的能力 |
| Parallelism | 並行 | 實際上同時執行多個任務 |
| Thread | 執行緒 | 程式執行的最小單位 |
| Process | 程序/進程 | 執行中的程式實例 |
| Multithreading | 多執行緒 | 使用多個執行緒的程式設計技術 |
| Core | 核心 | CPU 中可獨立執行指令的單元 |
| Context Switch | 上下文切換 | CPU 在不同執行緒間切換的過程 |
| Time Slicing | 時間分片 | 作業系統分配 CPU 時間給各執行緒的機制 |

---

### 九、本課重點回顧

1. **並發（Concurrency）** 是一種程式結構，強調處理多個任務的能力
2. **並行（Parallelism）** 是一種執行方式，強調同時執行多個任務
3. 並發程式在單核心上會以時間分片方式執行
4. 並發程式在多核心上可以真正並行執行，獲得效能提升
5. C++ 使用 `<thread>` 標頭檔提供多執行緒支援
6. `std::thread` 用於建立和管理執行緒
7. 多執行緒程式的執行順序具有不確定性

---

### 十、課後練習

1. **修改迭代次數**：將 iterations 改為 5 或 10，觀察時間變化
2. **增加任務數量**：新增任務 D、E、F，觀察並發執行的效果
3. **觀察你的硬體**：記錄 `hardware_concurrency()` 的值，思考如果任務數量超過這個值會怎樣
4. **移除 sleep**：把 `sleep_for` 註解掉，觀察輸出會有什麼變化

---

### 下一課預告

在 **課程 1.2：為什麼需要多執行緒** 中，我們將探討：
- 多執行緒程式設計的實際應用場景
- 效能提升的具體案例
- 響應性改善的重要性
- 多執行緒的適用時機判斷

---

準備好繼續下一課了嗎？


這是一個很好的問題！讓我從作業系統和硬體層面來解釋 Context Switch 的機制。

## 簡短回答

**這是由作業系統自動處理的，程式設計師不需要手動管理。**

---

## 詳細解釋

### Context Switch 的運作機制

```
時間軸:
────────────────────────────────────────────────────────────

CPU0 執行 Thread A          OS 介入           CPU1 繼續執行 Thread A
    │                          │                      │
    ▼                          ▼                      ▼
┌─────────┐              ┌──────────┐            ┌─────────┐
│ 執行中  │  ──觸發──>   │ 保存狀態 │  ──排程──> │ 恢復狀態│
│ Thread A│              │ 到 PCB   │            │ 從 PCB  │
└─────────┘              └──────────┘            └─────────┘
```

### 1. 什麼被保存？（Thread Context）

當 Context Switch 發生時，OS 會保存該 thread 的完整執行狀態：

```
┌─────────────────────────────────────────────────┐
│           Thread Control Block (TCB)            │
│         或 Process Control Block (PCB)          │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │  通用暫存器 (General Purpose Registers) │    │
│  │  • RAX, RBX, RCX, RDX, ...              │    │
│  │  • R8-R15 (x86-64)                      │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │  程式計數器 (Program Counter / RIP)     │    │
│  │  • 下一條要執行的指令位址               │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │  堆疊指標 (Stack Pointer / RSP)         │    │
│  │  • 目前堆疊的位置                       │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │  狀態暫存器 (RFLAGS)                    │    │
│  │  • CPU 狀態旗標                         │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │  浮點/向量暫存器                        │    │
│  │  • FPU 狀態, SSE/AVX 暫存器             │    │
│  └─────────────────────────────────────────┘    │
│                                                 │
└─────────────────────────────────────────────────┘
```

### 2. Context Switch 的完整流程

```
步驟 1: 觸發 (在 CPU0 上)
─────────────────────────
• Timer interrupt (時間片用完)
• I/O 等待
• 主動 yield
• 更高優先級 thread 就緒
        │
        ▼
步驟 2: 保存狀態 (OS Kernel)
─────────────────────────
• 進入 kernel mode
• 將 CPU0 所有暫存器值 → 寫入 Thread A 的 TCB
• TCB 存放在記憶體中 (所有 CPU 都能存取)
        │
        ▼
步驟 3: 排程決策 (Scheduler)
─────────────────────────
• 選擇下一個要執行的 thread
• 決定在哪個 CPU 上執行
        │
        ▼
步驟 4: 恢復狀態 (在 CPU1 上)
─────────────────────────
• 從 Thread A 的 TCB 讀取保存的狀態
• 將狀態載入到 CPU1 的暫存器
• 切換到 user mode
• 從 Program Counter 指向的位置繼續執行
```

### 3. 記憶體是共享的

這是關鍵點：

```
┌─────────────────────────────────────────────────────────┐
│                     主記憶體 (RAM)                       │
│                                                         │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│   │  Thread A   │  │  Thread A   │  │  Thread A   │     │
│   │   的 TCB    │  │   的 Stack  │  │   的 Heap   │     │
│   └─────────────┘  └─────────────┘  └─────────────┘     │
│          ▲                ▲                ▲            │
└──────────│────────────────│────────────────│────────────┘
           │                │                │
     ┌─────┴─────┐    ┌─────┴─────┐    ┌─────┴─────┐
     │   CPU0    │    │   CPU1    │    │   CPU2    │
     │  可存取   │    │  可存取   │    │  可存取   │
     └───────────┘    └───────────┘    └───────────┘
```

**重點：** TCB、Stack、Heap 都在共享記憶體中，任何 CPU 都能存取。

---

## 程式設計師需要關心什麼？

雖然 Context Switch 本身是自動的，但在多執行緒程式設計中，你需要處理：

### 你不需要管的（OS 自動處理）
- 暫存器的保存/恢復
- Program Counter 的追蹤
- Stack 的切換
- 執行緒在哪個 CPU 上執行

### 你需要管的（程式設計師責任）
```cpp
// 多個 thread 存取共享資料時，需要同步機制
std::mutex mtx;
int shared_data = 0;

void thread_function() {
    std::lock_guard<std::mutex> lock(mtx);  // 你需要處理這個
    shared_data++;                           // 保護共享資料
}
```

---

## 簡單比喻

想像一個接力賽跑：

```
情境：跑者 A (Thread) 需要休息，跑者 B (另一個 CPU) 接手

┌──────────────────────────────────────────────────────────┐
│                                                          │
│   跑者 A 在 CPU0 跑          裁判 (OS) 介入               │
│        │                          │                      │
│        ▼                          ▼                      │
│   ┌─────────┐              ┌──────────────┐              │
│   │ • 目前位置 (PC)        │ 記錄到計分板  │              │
│   │ • 已跑距離             │ (TCB in RAM) │              │
│   │ • 體力狀態 (暫存器)    │              │              │
│   └─────────┘              └──────────────┘              │
│                                    │                     │
│                                    ▼                     │
│                            ┌──────────────┐              │
│                            │ CPU1 空閒了  │              │
│                            │ 讀取計分板   │              │
│                            │ 從記錄點繼續 │              │
│                            └──────────────┘              │
│                                                          │
│   計分板 (TCB) 在公共區域，任何人都能讀取                 │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 總結

| 問題 | 答案 |
|------|------|
| 誰負責保存/恢復狀態？ | **作業系統 (OS Kernel)** |
| 狀態存在哪裡？ | **記憶體中的 TCB/PCB** |
| CPU1 怎麼知道 CPU0 的狀態？ | **從共享記憶體的 TCB 讀取** |
| 程式設計師需要處理嗎？ | **不需要處理 Context Switch 本身** |
| 程式設計師需要處理什麼？ | **共享資料的同步 (mutex, atomic 等)** |

這就是為什麼你寫多執行緒程式時，只需要關心 **資料同步**，而不需要關心 thread 會在哪個 CPU 上執行。OS 會處理所有底層的 Context Switch 細節！

有任何問題想深入了解嗎？
*/

// 檔案名稱：lesson_1_1_concurrency_demo.cpp
// 課程：1.1 - 什麼是並行與並發
// 說明：示範並發執行的基本概念

#include <iostream>
#include <thread>
#include <chrono>

// 模擬一個需要時間的任務
void performTask(const std::string& taskName, int iterations) {
    for (int i = 1; i <= iterations; ++i) {
        // 輸出目前的進度
        std::cout << "[" << taskName << "] 執行第 " << i 
                  << " 次迭代（執行緒 ID: " 
                  << std::this_thread::get_id() << "）" << std::endl;
        
        // 模擬工作需要一些時間
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    std::cout << "[" << taskName << "] 完成！" << std::endl;
}

int main() {
    std::cout << "========================================" << std::endl;
    std::cout << "    並發執行示範程式" << std::endl;
    std::cout << "========================================" << std::endl;
    std::cout << "主執行緒 ID: " << std::this_thread::get_id() << std::endl;
    std::cout << "硬體支援的執行緒數量: " 
              << std::thread::hardware_concurrency() << std::endl;
    std::cout << "----------------------------------------" << std::endl;

    // 記錄開始時間
    auto startTime = std::chrono::steady_clock::now();

    // 方式一：循序執行（非並發）
    std::cout << "\n【方式一】循序執行：" << std::endl;
    auto seqStart = std::chrono::steady_clock::now();
    
    performTask("任務A", 3);
    performTask("任務B", 3);
    performTask("任務C", 3);
    
    auto seqEnd = std::chrono::steady_clock::now();
    auto seqDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
        seqEnd - seqStart).count();
    std::cout << "循序執行總時間: " << seqDuration << " 毫秒" << std::endl;

    std::cout << "\n----------------------------------------" << std::endl;

    // 方式二：並發執行
    std::cout << "\n【方式二】並發執行：" << std::endl;
    auto concStart = std::chrono::steady_clock::now();
    
    // 建立三個執行緒，每個執行緒執行一個任務
    std::thread threadA(performTask, "任務A", 3);
    std::thread threadB(performTask, "任務B", 3);
    std::thread threadC(performTask, "任務C", 3);
    
    // 等待所有執行緒完成
    threadA.join();
    threadB.join();
    threadC.join();
    
    auto concEnd = std::chrono::steady_clock::now();
    auto concDuration = std::chrono::duration_cast<std::chrono::milliseconds>(
        concEnd - concStart).count();
    std::cout << "並發執行總時間: " << concDuration << " 毫秒" << std::endl;

    std::cout << "\n========================================" << std::endl;
    std::cout << "效能比較：" << std::endl;
    std::cout << "循序執行: " << seqDuration << " 毫秒" << std::endl;
    std::cout << "並發執行: " << concDuration << " 毫秒" << std::endl;
    std::cout << "加速比: " << static_cast<double>(seqDuration) / concDuration 
              << " 倍" << std::endl;
    std::cout << "========================================" << std::endl;

    return 0;
}
