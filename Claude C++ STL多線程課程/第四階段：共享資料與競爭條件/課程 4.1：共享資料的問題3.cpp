/*
# 第四階段：共享資料與競爭條件

## 課程 4.1：共享資料的問題

---

### 引言

多執行緒程式設計最大的挑戰在於**共享資料**。當多個執行緒同時存取同一份資料，且至少有一個執行緒進行寫入時，問題就會產生。本課深入分析這個問題的本質。

---

### 一、共享資料的類型

```
┌─────────────────────────────────────────────────────────────┐
│                    共享資料的來源                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  • 全域變數                                                  │
│  • 靜態變數                                                  │
│  • 堆積上的物件（透過指標/引用共享）                          │
│  • 類別成員變數（多執行緒存取同一物件）                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 二、讀取 vs 寫入

```
┌─────────────────────────────────────────────────────────────┐
│                    存取類型與安全性                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  多執行緒同時讀取    →  安全 ✓                               │
│  一個寫入 + 一個讀取  →  不安全 ✗（資料競爭）                 │
│  多執行緒同時寫入    →  不安全 ✗（資料競爭）                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 三、問題展示：計數器

```cpp
#include <iostream>
#include <thread>
#include <vector>

int counter = 0;

void increment() {
    for (int i = 0; i < 100000; ++i) {
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(increment);
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "預期: 1000000" << std::endl;
    std::cout << "實際: " << counter << std::endl;
    
    return 0;
}
```

輸出（每次不同）：
```
預期: 1000000
實際: 387432
```

---

### 四、為什麼會出錯？

`++counter` 看起來是一個操作，實際上是三步：

```
┌─────────────────────────────────────────────────────────────┐
│                   ++counter 的真實步驟                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 讀取：從記憶體讀取 counter 的值到 CPU 暫存器             │
│  2. 修改：在暫存器中將值 +1                                  │
│  3. 寫入：將暫存器的值寫回記憶體                             │
│                                                             │
│  這三步不是原子的，可能被其他執行緒打斷！                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 五、交錯執行的災難

```
時間   執行緒A              執行緒B              counter（記憶體）
────────────────────────────────────────────────────────────────
 1    讀取 counter (0)                               0
 2                         讀取 counter (0)          0
 3    +1 得到 1                                      0
 4                         +1 得到 1                 0
 5    寫回 1                                         1
 6                         寫回 1                    1
────────────────────────────────────────────────────────────────
結果：兩次 ++，但 counter 只變成 1！
```

---

### 六、更複雜的例子：銀行轉帳

```cpp
#include <iostream>
#include <thread>

struct Account {
    int balance = 1000;
};

Account accountA, accountB;

void transfer(Account& from, Account& to, int amount) {
    if (from.balance >= amount) {
        from.balance -= amount;
        to.balance += amount;
    }
}

int main() {
    std::thread t1([&]() {
        for (int i = 0; i < 1000; ++i) {
            transfer(accountA, accountB, 1);
        }
    });
    
    std::thread t2([&]() {
        for (int i = 0; i < 1000; ++i) {
            transfer(accountB, accountA, 1);
        }
    });
    
    t1.join();
    t2.join();
    
    int total = accountA.balance + accountB.balance;
    std::cout << "A: " << accountA.balance << std::endl;
    std::cout << "B: " << accountB.balance << std::endl;
    std::cout << "總額: " << total << " (應為 2000)" << std::endl;
    
    return 0;
}
```

可能輸出：
```
A: 1042
B: 1036
總額: 2078 (應為 2000)
```

錢憑空產生了！這是嚴重的資料損毀。

---

### 七、資料競爭的定義

根據 C++ 標準，**資料競爭（Data Race）** 發生於：

```
┌─────────────────────────────────────────────────────────────┐
│                  資料競爭的條件                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  同時滿足以下條件：                                          │
│                                                             │
│  1. 兩個或多個執行緒同時存取同一記憶體位置                   │
│  2. 至少有一個是寫入操作                                    │
│  3. 沒有同步機制保護                                        │
│                                                             │
│  結果：未定義行為（Undefined Behavior）                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 八、不只是錯誤的結果

資料競爭導致的是**未定義行為**，可能出現：

- 錯誤的計算結果
- 程式崩潰
- 資料損毀
- 看似正確但偶爾出錯（最難除錯）
- 在某些機器正常，換台機器就出錯

---

### 九、哪些操作是安全的？

```cpp
#include <iostream>
#include <thread>

const int readOnlyData = 42;  // 唯讀資料

void reader() {
    // 安全：只有讀取，沒有寫入
    std::cout << readOnlyData << std::endl;
}

int main() {
    std::thread t1(reader);
    std::thread t2(reader);
    
    t1.join();
    t2.join();
    
    return 0;
}
```

**規則**：只要沒有寫入，多執行緒讀取是安全的。

---

### 十、解決方案預覽

```
┌─────────────────────────────────────────────────────────────┐
│                  解決資料競爭的方法                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 互斥鎖（Mutex）                                         │
│     確保同一時間只有一個執行緒存取資料                       │
│                                                             │
│  2. 原子操作（Atomic）                                      │
│     使用硬體支援的不可分割操作                               │
│                                                             │
│  3. 避免共享                                                │
│     每個執行緒使用自己的資料副本                             │
│                                                             │
│  4. 不可變資料                                              │
│     資料建立後不再修改                                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

### 十一、本課重點回顧

1. 多執行緒存取共享資料是危險的
2. 讀取 + 寫入或多重寫入會造成資料競爭
3. `++counter` 不是原子操作，由三個步驟組成
4. 資料競爭導致**未定義行為**
5. 只有純讀取是安全的
6. 解決方案：互斥鎖、原子操作、避免共享

---

### 下一課預告

在 **課程 4.2：不變量與競爭條件** 中，我們將學習：
- 什麼是不變量（Invariant）
- 不變量被破壞的情況
- 如何維護資料的一致性

---

準備好繼續嗎？
*/



#include <iostream>
#include <thread>

const int readOnlyData = 42;  // 唯讀資料

void reader() {
    // 安全：只有讀取，沒有寫入
    std::cout << readOnlyData << std::endl;
}

int main() {
    std::thread t1(reader);
    std::thread t2(reader);
    
    t1.join();
    t2.join();
    
    return 0;
}
