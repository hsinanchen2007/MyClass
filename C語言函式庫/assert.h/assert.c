/*
    函数名: assert

    头文件：<assert.h> 

    函数原型: void assert( int expression );

    功能： 断言一个表达式是否正确

    参数：expression如果其值为假（即为0），那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行

    返回值：没有返回值

    补充：

    1、频繁的调用会极大的影响程序的性能，增加额外的开销。在调试结束后，可以通过在包含#include <assert.h>的语句之前插入 #define NDEBUG 来禁用assert调用。
    2、在函数开始处检验传入参数的合法性。
    3、每个assert只检验一个条件，因为同时检验多个条件时，如果断言失败，无法直观的判断是哪个条件失败。
    4、不能使用改变环境的语句，因为assert只在DEBUG个生效，如果这么做，会使用程序在真正运行时忽略了assert语句就会遇到问题，如：

        错误：  

        assert(i++ < 100);
        这是因为如果出错，比如在执行之前i=100，那么这条语句就不会执行，那么i++这条命令就没有执行。

        正确：

        assert(i < 100);  i++;

    5、assert和后面的语句应空一行，以形成逻辑和视觉上的一致感。
    6、有的地方，assert不能代替条件过滤。 assert是用来避免显而易见的错误的，而不是处理异常的。错误和异常是不一样的，错误是不应该出现的，异常是不可避免的。
       c语言异常可以通过条件判断来处理，其它语言有各自的异常处理机制。一个非常简单的使用assert的规律就是，在方法或者函数的最开始使用，如果在方法的中间使用
       则需要慎重考虑是否是应该的。方法的最开始还没开始一个功能过程，在一个功能过程执行中出现的问题几乎都是异常。

    程序例:   断言变量a<80，并将结果输出
*/

#include<assert.h>
#include<stdio.h>

int main(void){ 
   int a=50;
   assert(a<80);   //断言a<80,如果为0输出错误信息终止程序，否则继续执行 
   printf("Assert a is true\n"); 
   return(0); 
}
